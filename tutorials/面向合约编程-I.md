# 面向合约编程 - 第一部分

这个系列是关于[面向合约编程](https://en.wikipedia.org/wiki/Design_by_contract)和 Solidity 的。“合约”在这个语境中其实不是个以太坊合约，或者一个智能合约；它是一个用来描述函数或功能单元的（目前非正式的）定义。其基本思想就是一个函数必须被拆分成前置条件、功能体和后置条件，不论是在（合约的）描述说明中还是在代码里。

显然这个东西还有更多内容，不过我们之后再深究，现在我们要开始看看 Solidity 函数和接口的一些基本功能，以及怎样应用面向合约的技巧。

尽管 Solidity 非常简单，它也不是一种非常好写代码的语言。它有合约、依赖库、函数、定制修饰器和事件。函数有很多需要正确选择的标准修饰器，并且有些修饰器实际上干些啥并不是很明显（例如`external`和`internal`）。特定的修饰器（比如`constant`）至今仍未强制使用，甚至就算你把所有修饰器都用对了，他们也会有问题，比如说在某些类型的函数中，某些 Solidity 类型不能被用作输入或输出数据。

话虽如此，习惯了也没那么糟糕，并且会越来越好。我在这里提到的情况并不是由于过差的语言设计，而仅仅因为缺少特定功能（语言的和 EVM 的）。这门编程语言还很年轻。但我还是觉得在进入合约部分前，有些东西必须要搞清楚。

（请注意，这些内容和观点的发布基础建立在此之上：实际的、正式的面向合约编程并不是标准；它没有全面的语言支持，也只有很少的信息和样例代码。因此，这些内容有一定程度上的探索和实验，请小心不要直接应用这些技巧，不论正确与否，也不要假定这会让合约100%安全。）

### 函数及标准<ruby>修饰器<rp>(</rp><rt>Modifier</rt><rp>)</rp></ruby>

修饰器被添加到变量和函数上以影响它们的行为。所有的基本修饰器都可以在[这里](https://en.wikipedia.org/wiki/Design_by_contract)找到。绝大多数常见的修饰器（譬如 public 和 private）都可用，但有些表现得和预期有一点点不同。

在描述所有修饰器之前我必须要重新过一下`call`和`transaction`机制：

一个`transaction`是一个由用户发向合约账户或外部账户、改变（或至少尝试改变）世界状态的已签名交易。交易被放进 tx 序列中并且不被认为是有效的，直到最终被挖进区块里。在发送以太币或执行任何**写入**操作时，必须使用交易。

一个`call`被用来从链上**读取**数据，或者做不改变世界状态的运算，因此不需要一个有效签名或者网络上其他用户的共识。一个使用`call`的例子应该是通过其公共访问方法检查合约的一个字段值。

#### `constant`

`constant`修改器尚未被 Solidity 编译器要求强制使用，但其目的是向编译器和调用者发出消息：该函数并不改变世界状态。`constant`会出现在 JSON ABI 文件说明里，被`web3.js`——官方 JavaScript API——用来决定是用`transaction`还是`call`来调用函数。
