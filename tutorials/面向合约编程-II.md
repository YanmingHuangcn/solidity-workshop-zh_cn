# 面向合约编程 - 第II部分

这是面向合约编程教程的第二部分。在这里我们要研究研究后置条件，和一些更复杂的函数。

请注意：就像在第一部分的一样，我们只用几个示例来展示怎么样在 Solidity 中使用自定义修饰器来应用一些简单的面向合约技巧。我们会在之后的内容里介绍更多细节，现在主要是为了实验和探索。

### 后置条件

后置条件可以用来确保跑了函数之后设想的事情确实发生了。通常这些事情会是某些状态的声明，譬如调用者的余额或者某个合约字段。我们在这里不限制可能要（或需要）检查的状态的类型。

一个很简单的后置条件的例子：

```Solidity
contract PostCheck {

    uint public data = 0;


    // 检查‘data’字段确实被改变成了‘_data’的值
    modifier data_is_valid(uint _data) {
        _;
        if (_data != data)
            throw;
    }


    function setData(uint _data) data_is_valid(_data) {
        data = _data;
    }
}
```

请注意`_`在后置条件修饰器里的位置；这样会在*检查之前*执行被修饰的函数，与前置条件修饰器里先检查再执行相反。

可以结合使用前置和后置条件。例子：

```Solidity
contract PrePostCheck {

    uint public data = 0;


    // 检查输入的‘_data’的值不等于'data'里已保存的值
    modifier data_is_valid(uint _data) {
        if (_data == data)
           throw;
        _；
    }


    // 检查‘data’字段确实被改变成了‘_data’的值
    modifier data_was_updated(uint _data) {
        _；
        if (_data != data)
            throw;
    }


    function setData(uint _data) data_is_valid(_data) data_was_updated(_data) {
        data = _data;
    }
}
```

这就是个非常安全的函数。它不仅检查了输入数据的有效性（在这个案例里是不与已存储的数据相同），还在返回前检查了 data 变量确实被改变了。因为单元测试本质上跟第一部分里一样，我们就不搞了。

### 修饰器的顺序

在给函数添加修饰器的时候，顺序非常重要。修饰器应当从左到右添加，因为它们从左到右被执行。意思就是说如果前后置都有，我们应该把前置放在前面。在语义上前后置条件的修饰器没有任何区别，所以最好（我觉得）认认真真命名。一个思路就是把所有的修饰器名字前面都挂上`pre`或者`post`，比如`pre_data_is_zero`。在 Solidity 风格指南里没有任何推荐。

### `return` vs `throw`

如果前置和后置条件对不上，怎么样跳出函数其实会很难抉择。鉴于 Solidity 在这个事情上的工作方式，问题就归结于是在修饰器里允许`return`还是直接`throw`。

个人而言，我不知道最佳解决方式是什么。我倾向于每次都抛出。这样的方式把修饰器当作传统的断言处理，且如果断言失败了，就意味着（理论上）我们能保证这次代码执行没有意料之外的后果。我说“理论上”，意思是只要修饰器是好好写的并且添加也正确、执行也正常（比如没有用奇怪的 EVM 漏洞），那就是真的。这是看起来最面向合约的做法了。副作用是`throw`不允许调用者进行任何形式的恢复，因为没有`catch`，但就算你可以，也没有错误类型。但就像我第一部分指出的，在使用修饰器的时候也没办法返回错误代码，所以这个问题也不重要了。

### 分离函数逻辑与条件

有些时候去判断一个条件应该放在在修饰器里（前置或者后置条件）还是应该作为函数体的一部分会比较难。这里有个合约，带着比第一部分的那些更棘手一点的函数：

```Solidity
contract Token {
    
}
```
